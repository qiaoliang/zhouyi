# 周易通APP - 后端项目结构和代码示例

## 完整代码示例

### 1. 用户模块 (User Module)

#### user.module.ts

```typescript
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UserController } from './user.controller';
import { UserService } from './user.service';
import { User, UserSchema } from './schemas/user.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService],
})
export class UserModule {}
```

#### user.service.ts

```typescript
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './schemas/user.schema';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { hash } from 'bcrypt';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<User> {
    // 检查手机号是否已存在
    const existingUser = await this.userModel.findOne({
      phoneNumber: createUserDto.phoneNumber,
    });

    if (existingUser) {
      throw new ConflictException('手机号已被注册');
    }

    // 创建用户
    const user = new this.userModel(createUserDto);
    return user.save();
  }

  async findById(id: string): Promise<User> {
    const user = await this.userModel.findById(id);
    if (!user) {
      throw new NotFoundException('用户不存在');
    }
    return user;
  }

  async findByPhoneNumber(phoneNumber: string): Promise<User | null> {
    return this.userModel.findOne({ phoneNumber });
  }

  async findByUnionId(unionId: string): Promise<User | null> {
    return this.userModel.findOne({ unionId });
  }

  async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {
    const user = await this.findById(id);
    Object.assign(user, updateUserDto);
    return user.save();
  }

  async updateMembership(userId: string, membership: any): Promise<User> {
    const user = await this.findById(userId);
    user.membership = membership;
    return user.save();
  }
}
```

#### user.controller.ts

```typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Body,
  Param,
  UseGuards,
  Request,
} from '@nestjs/common';
import { AuthGuard } from '../../common/guards/auth.guard';
import { UserService } from './user.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { Public } from '../../common/decorators/public.decorator';

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get('profile')
  @UseGuards(AuthGuard)
  getProfile(@Request() req) {
    return this.userService.findById(req.user.userId);
  }

  @Get(':id')
  @UseGuards(AuthGuard)
  findOne(@Param('id') id: string) {
    return this.userService.findById(id);
  }

  @Post()
  @Public()
  create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @Put(':id')
  @UseGuards(AuthGuard)
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.userService.update(id, updateUserDto);
  }
}
```

#### create-user.dto.ts

```typescript
import { IsString, IsOptional, IsEnum, IsPhoneNumber } from 'class-validator';

export class CreateUserDto {
  @IsString()
  @IsOptional()
  unionId?: string;

  @IsString()
  @IsOptional()
  openId?: string;

  @IsString()
  @IsPhoneNumber('CN')
  phoneNumber: string;

  @IsString()
  @IsOptional()
  nickname?: string;

  @IsString()
  @IsOptional()
  avatar?: string;

  @IsEnum(['free', 'monthly', 'yearly'])
  @IsOptional()
  membershipType?: 'free' | 'monthly' | 'yearly';

  @IsEnum(['active', 'suspended', 'deleted'])
  @IsOptional()
  status?: 'active' | 'suspended' | 'deleted';
}
```

---

### 2. 认证模块 (Auth Module)

#### auth.module.ts

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { UserModule } from '../user/user.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { WechatStrategy } from './strategies/wechat.strategy';

@Module({
  imports: [
    UserModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('app.jwt.secret'),
        signOptions: {
          expiresIn: configService.get<string>('app.jwt.expiresIn'),
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, WechatStrategy],
  exports: [AuthService],
})
export class AuthModule {}
```

#### auth.service.ts

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { UserService } from '../user/user.service';
import { LoginDto } from './dto/login.dto';
import { WechatLoginDto } from './dto/wechat-login.dto';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}

  async validateUser(phoneNumber: string, password: string): Promise<any> {
    const user = await this.userService.findByPhoneNumber(phoneNumber);
    if (!user) {
      throw new UnauthorizedException('用户不存在');
    }
    return user;
  }

  async login(loginDto: LoginDto) {
    const user = await this.validateUser(loginDto.phoneNumber, loginDto.code);

    // 生成JWT令牌
    const payload = {
      userId: user._id.toString(),
      phoneNumber: user.phoneNumber,
    };

    const accessToken = this.jwtService.sign(payload);
    const refreshToken = this.jwtService.sign(payload, {
      expiresIn: this.configService.get<string>('app.jwt.refreshExpiresIn'),
    });

    return {
      accessToken,
      refreshToken,
      user: {
        id: user._id,
        nickname: user.nickname,
        avatar: user.avatar,
        membership: user.membership,
      },
    };
  }

  async wechatLogin(wechatLoginDto: WechatLoginDto) {
    // 这里需要调用微信API验证code
    // const wechatUser = await this.verifyWechatCode(wechatLoginDto.code);

    let user = await this.userService.findByUnionId(wechatLoginDto.unionId);

    if (!user) {
      // 创建新用户
      user = await this.userService.create({
        unionId: wechatLoginDto.unionId,
        nickname: wechatLoginDto.nickname,
        avatar: wechatLoginDto.avatar,
      });
    }

    // 生成JWT令牌
    const payload = {
      userId: user._id.toString(),
      unionId: user.unionId,
    };

    const accessToken = this.jwtService.sign(payload);
    const refreshToken = this.jwtService.sign(payload, {
      expiresIn: this.configService.get<string>('app.jwt.refreshExpiresIn'),
    });

    return {
      accessToken,
      refreshToken,
      user: {
        id: user._id,
        nickname: user.nickname,
        avatar: user.avatar,
        membership: user.membership,
      },
    };
  }

  async refresh(refreshToken: string) {
    try {
      const payload = this.jwtService.verify(refreshToken);
      const user = await this.userService.findById(payload.userId);

      const newPayload = {
        userId: user._id.toString(),
        phoneNumber: user.phoneNumber,
      };

      const accessToken = this.jwtService.sign(newPayload);

      return { accessToken };
    } catch (error) {
      throw new UnauthorizedException('刷新令牌无效');
    }
  }
}
```

#### jwt.strategy.ts

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('app.jwt.secret'),
    });
  }

  async validate(payload: any) {
    if (!payload.userId) {
      throw new UnauthorizedException();
    }
    return { userId: payload.userId, ...payload };
  }
}
```

---

### 3. 卜卦模块 (Divination Module)

#### divination.service.ts

```typescript
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { DivinationRecord, DivinationDocument } from './schemas/divination.schema';

@Injectable()
export class DivinationService {
  constructor(
    @InjectModel(DivinationRecord.name) private divinationModel: Model<DivinationDocument>,
  ) {}

  // 金钱课起卦
  async createDivination(userId: string, lines: number[]) {
    // 生成卦象
    const hexagram = this.generateHexagram(lines);

    const record = new this.divinationModel({
      userId,
      hexagram,
      createdAt: new Date(),
    });

    return record.save();
  }

  // 生成卦象算法
  private generateHexagram(lines: number[]) {
    // 六爻从下到上 (1-6)
    const yaoci = lines.map((value, index) => ({
      position: index + 1,
      yinYang: value % 2 === 0 ? 'yin' : 'yang',
      changing: value === 6 || value === 9, // 6=老阴, 9=老阳为变爻
    }));

    // 计算主卦
    const primarySymbol = yaoci.map(y => y.yinYang === 'yang' ? '1' : '0').join('');
    const primarySequence = this.symbolToSequence(primarySymbol);
    const primary = this.getHexagramBySequence(primarySequence);

    // 计算变卦
    const changedYaoci = yaoci.map(y => ({
      ...y,
      yinYang: y.changing ? (y.yinYang === 'yang' ? 'yin' : 'yang') : y.yinYang,
    }));
    const changedSymbol = changedYaoci.map(y => y.yinYang === 'yang' ? '1' : '0').join('');
    const changedSequence = this.symbolToSequence(changedSymbol);
    const changed = this.getHexagramBySequence(changedSequence);

    // 计算互卦 (二三四爻为下卦，三四五爻为上卦)
    const mutualUpper = [yaoci[2], yaoci[3], yaoci[4]];
    const mutualLower = [yaoci[1], yaoci[2], yaoci[3]];
    const mutualSymbol = [
      ...mutualUpper.map(y => y.yinYang === 'yang' ? '1' : '0'),
      ...mutualLower.map(y => y.yinYang === 'yang' ? '1' : '0'),
    ].join('');
    const mutualSequence = this.symbolToSequence(mutualSymbol);
    const mutual = this.getHexagramBySequence(mutualSequence);

    const changingLines = yaoci.filter(y => y.changing).map(y => y.position);

    return {
      primary: {
        name: primary.name,
        symbol: primary.symbol,
        sequence: primary.sequence,
      },
      lines: yaoci,
      changed: {
        name: changed.name,
        symbol: changed.symbol,
        sequence: changed.sequence,
      },
      mutual: {
        name: mutual.name,
        symbol: mutual.symbol,
        sequence: mutual.sequence,
      },
      changingLines,
    };
  }

  // 二进制符号转序号
  private symbolToSequence(symbol: string): number {
    const binaryMap: { [key: string]: number } = {
      '111111': 1,  '000000': 2,  '100010': 3,  '010001': 4,
      '111010': 5,  '010111': 6,  '010000': 7,  '000010': 8,
      // ... 完整的64卦映射
    };
    return binaryMap[symbol] || 1;
  }

  // 根据序号获取卦象信息
  private getHexagramBySequence(sequence: number) {
    const hexagrams = [
      { sequence: 1, name: '乾为天', symbol: '䷀' },
      { sequence: 2, name: '坤为地', symbol: '䷁' },
      // ... 完整的64卦数据
    ];
    return hexagrams.find(h => h.sequence === sequence) || hexagrams[0];
  }
}
```

---

### 4. 定时任务

#### daily-hexagram.job.ts

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { DivinationService } from '../modules/divination/divination.service';
import { PushService } from '../services/push/push.service';

@Injectable()
export class DailyHexagramJob {
  private readonly logger = new Logger(DailyHexagramJob.name);

  constructor(
    private readonly divinationService: DivinationService,
    private readonly pushService: PushService,
  ) {}

  // 每天早上8点生成今日卦象
  @Cron(CronExpression.EVERY_DAY_AT_8AM, {
    timeZone: 'Asia/Shanghai',
  })
  async handleDailyHexagram() {
    this.logger.log('开始生成每日一卦...');

    try {
      // 随机选择一个卦象
      const todayHexagram = await this.generateTodayHexagram();

      // 推送给所有用户
      await this.pushService.sendDailyHexagram(todayHexagram);

      this.logger.log(`每日一卦生成成功: ${todayHexagram.name}`);
    } catch (error) {
      this.logger.error('每日一卦生成失败', error);
    }
  }

  private async generateTodayHexagram() {
    // 随机生成1-64之间的数字
    const sequence = Math.floor(Math.random() * 64) + 1;
    // 获取卦象信息
    return this.getHexagramBySequence(sequence);
  }
}
```

---

### 5. 运行脚本

#### 启动开发服务器

```bash
# 安装依赖
pnpm install

# 启动开发服务器
pnpm start:dev

# 服务器将在 http://localhost:3000 启动
```

#### 健康检查

```bash
# 健康检查接口
curl http://localhost:3000/api/v1/health

# 预期响应
{
  "success": true,
  "data": {
    "status": "ok",
    "timestamp": 1704960000000
  }
}
```

---

**文档编写**: Claude
**最后更新**: 2026-01-11
